import {
  require_react
} from "./chunk-2MHMPIZK.js";
import {
  __commonJS
} from "./chunk-HYZYPRER.js";

// ../../../../../node_modules/next/dist/client/components/hooks-server-context.js
var require_hooks_server_context = __commonJS({
  "../../../../../node_modules/next/dist/client/components/hooks-server-context.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      DynamicServerError: function() {
        return DynamicServerError;
      },
      isDynamicServerError: function() {
        return isDynamicServerError;
      }
    });
    var DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";
    var DynamicServerError = class extends Error {
      constructor(description) {
        super("Dynamic server usage: " + description);
        this.description = description;
        this.digest = DYNAMIC_ERROR_CODE;
      }
    };
    function isDynamicServerError(err) {
      if (typeof err !== "object" || err === null || !("digest" in err) || typeof err.digest !== "string") {
        return false;
      }
      return err.digest === DYNAMIC_ERROR_CODE;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../node_modules/next/dist/client/components/static-generation-bailout.js
var require_static_generation_bailout = __commonJS({
  "../../../../../node_modules/next/dist/client/components/static-generation-bailout.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      StaticGenBailoutError: function() {
        return StaticGenBailoutError;
      },
      isStaticGenBailoutError: function() {
        return isStaticGenBailoutError;
      }
    });
    var NEXT_STATIC_GEN_BAILOUT = "NEXT_STATIC_GEN_BAILOUT";
    var StaticGenBailoutError = class extends Error {
      constructor(...args) {
        super(...args);
        this.code = NEXT_STATIC_GEN_BAILOUT;
      }
    };
    function isStaticGenBailoutError(error) {
      if (typeof error !== "object" || error === null || !("code" in error)) {
        return false;
      }
      return error.code === NEXT_STATIC_GEN_BAILOUT;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../../node_modules/next/dist/lib/url.js
var require_url = __commonJS({
  "../../../../../node_modules/next/dist/lib/url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getPathname: function() {
        return getPathname;
      },
      isFullStringUrl: function() {
        return isFullStringUrl;
      }
    });
    var DUMMY_ORIGIN = "http://n";
    function getUrlWithoutHost(url) {
      return new URL(url, DUMMY_ORIGIN);
    }
    function getPathname(url) {
      return getUrlWithoutHost(url).pathname;
    }
    function isFullStringUrl(url) {
      return /https?:\/\//.test(url);
    }
  }
});

// ../../../../../node_modules/next/dist/server/app-render/dynamic-rendering.js
var require_dynamic_rendering = __commonJS({
  "../../../../../node_modules/next/dist/server/app-render/dynamic-rendering.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      Postpone: function() {
        return Postpone;
      },
      createPostponedAbortSignal: function() {
        return createPostponedAbortSignal;
      },
      createPrerenderState: function() {
        return createPrerenderState;
      },
      formatDynamicAPIAccesses: function() {
        return formatDynamicAPIAccesses;
      },
      markCurrentScopeAsDynamic: function() {
        return markCurrentScopeAsDynamic;
      },
      trackDynamicDataAccessed: function() {
        return trackDynamicDataAccessed;
      },
      trackDynamicFetch: function() {
        return trackDynamicFetch;
      },
      usedDynamicAPIs: function() {
        return usedDynamicAPIs;
      }
    });
    var _react = _interop_require_default(require_react());
    var _hooksservercontext = require_hooks_server_context();
    var _staticgenerationbailout = require_static_generation_bailout();
    var _url = require_url();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var hasPostpone = typeof _react.default.unstable_postpone === "function";
    function createPrerenderState(isDebugSkeleton) {
      return {
        isDebugSkeleton,
        dynamicAccesses: []
      };
    }
    function markCurrentScopeAsDynamic(store, expression) {
      const pathname = (0, _url.getPathname)(store.urlPathname);
      if (store.isUnstableCacheCallback) {
        return;
      } else if (store.dynamicShouldError) {
        throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
      } else if (
        // We are in a prerender (PPR enabled, during build)
        store.prerenderState
      ) {
        postponeWithTracking(store.prerenderState, expression, pathname);
      } else {
        store.revalidate = 0;
        if (store.isStaticGeneration) {
          const err = new _hooksservercontext.DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
          store.dynamicUsageDescription = expression;
          store.dynamicUsageStack = err.stack;
          throw err;
        }
      }
    }
    function trackDynamicDataAccessed(store, expression) {
      const pathname = (0, _url.getPathname)(store.urlPathname);
      if (store.isUnstableCacheCallback) {
        throw new Error(`Route ${pathname} used "${expression}" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "${expression}" oustide of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`);
      } else if (store.dynamicShouldError) {
        throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
      } else if (
        // We are in a prerender (PPR enabled, during build)
        store.prerenderState
      ) {
        postponeWithTracking(store.prerenderState, expression, pathname);
      } else {
        store.revalidate = 0;
        if (store.isStaticGeneration) {
          const err = new _hooksservercontext.DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
          store.dynamicUsageDescription = expression;
          store.dynamicUsageStack = err.stack;
          throw err;
        }
      }
    }
    function Postpone({ reason, prerenderState, pathname }) {
      postponeWithTracking(prerenderState, reason, pathname);
    }
    function trackDynamicFetch(store, expression) {
      if (store.prerenderState) {
        postponeWithTracking(store.prerenderState, expression, store.urlPathname);
      }
    }
    function postponeWithTracking(prerenderState, expression, pathname) {
      assertPostpone();
      const reason = `Route ${pathname} needs to bail out of prerendering at this point because it used ${expression}. React throws this special object to indicate where. It should not be caught by your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
      prerenderState.dynamicAccesses.push({
        // When we aren't debugging, we don't need to create another error for the
        // stack trace.
        stack: prerenderState.isDebugSkeleton ? new Error().stack : void 0,
        expression
      });
      _react.default.unstable_postpone(reason);
    }
    function usedDynamicAPIs(prerenderState) {
      return prerenderState.dynamicAccesses.length > 0;
    }
    function formatDynamicAPIAccesses(prerenderState) {
      return prerenderState.dynamicAccesses.filter((access) => typeof access.stack === "string" && access.stack.length > 0).map(({ expression, stack }) => {
        stack = stack.split("\n").slice(4).filter((line) => {
          if (line.includes("node_modules/next/")) {
            return false;
          }
          if (line.includes(" (<anonymous>)")) {
            return false;
          }
          if (line.includes(" (node:")) {
            return false;
          }
          return true;
        }).join("\n");
        return `Dynamic API Usage Debug - ${expression}:
${stack}`;
      });
    }
    function assertPostpone() {
      if (!hasPostpone) {
        throw new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`);
      }
    }
    function createPostponedAbortSignal(reason) {
      assertPostpone();
      const controller = new AbortController();
      try {
        _react.default.unstable_postpone(reason);
      } catch (x) {
        controller.abort(x);
      }
      return controller.signal;
    }
  }
});
export default require_dynamic_rendering();
//# sourceMappingURL=next_dist_server_app-render_dynamic-rendering.js.map
